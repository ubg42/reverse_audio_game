<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Reverse Audio — Modern App</title>
<style>
  body {
    margin:0; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    background:#f2f2f7; color:#111; display:flex; flex-direction:column; min-height:100vh;
  }
  header {
    background:#fff; padding:14px; text-align:center; font-weight:600; font-size:17px;
    border-bottom:1px solid #ddd; position:sticky; top:0; z-index:10;
  }
  main {
    flex:1; display:flex; flex-direction:column; align-items:center; padding:20px;
  }
  #waveCanvas {
    width:100%; max-width:400px; height:140px; background:#fff;
    border-radius:12px; box-shadow:0 1px 4px rgba(0,0,0,0.08); margin:20px 0;
  }
  .record-btn {
    width:100px; height:100px; border-radius:50%; background:#ff3b30;
    display:flex; align-items:center; justify-content:center; color:#fff; font-size:16px;
    border:none; box-shadow:0 4px 12px rgba(0,0,0,0.25); cursor:pointer; transition:transform 0.1s;
  }
  .record-btn.recording { animation: pulse 1s infinite; }
  @keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.1);} }
  .controls {
    display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:20px;
  }
  .controls button {
    background:#fff; border:none; padding:10px 16px; border-radius:10px; font-size:15px;
    box-shadow:0 1px 4px rgba(0,0,0,0.08); cursor:pointer;
  }
  .controls button:disabled { opacity:0.4; cursor:not-allowed; }
  footer {
    background:#fff; padding:10px; font-size:12px; color:#666; text-align:center;
    border-top:1px solid #ddd;
  }
</style>
</head>
<body>

<header>Reverse Audio</header>
<main>
  <button id="recordBtn" class="record-btn">Rec</button>
  <canvas id="waveCanvas" width="400" height="140"></canvas>
  <div id="meta">No audio loaded</div>
  <div class="controls">
    <button id="stopBtn" disabled>Stop</button>
    <button id="playOriginal" disabled>Play</button>
    <button id="playReversed" disabled>Reverse</button>
    <button id="downloadBtn" disabled>Download</button>
    <input id="fileInput" type="file" accept="audio/*" style="display:none">
    <button id="fileOpen">Open File</button>
  </div>
</main>
<footer>Everything stays on your device. Audio is processed locally in your browser.</footer>

<script>
class ReverseAudioApp {
  constructor() {
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.gainNode = this.audioCtx.createGain();
    this.gainNode.connect(this.audioCtx.destination);

    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.originalBuffer = null;
    this.reversedBuffer = null;
    this.originalSource = null;
    this.reversedSource = null;

    // DOM
    this.recordBtn = document.getElementById('recordBtn');
    this.stopBtn = document.getElementById('stopBtn');
    this.playOriginal = document.getElementById('playOriginal');
    this.playReversed = document.getElementById('playReversed');
    this.downloadBtn = document.getElementById('downloadBtn');
    this.fileInput = document.getElementById('fileInput');
    this.fileOpen = document.getElementById('fileOpen');
    this.meta = document.getElementById('meta');
    this.canvas = document.getElementById('waveCanvas');
    this.ctx = this.canvas.getContext('2d');

    this.addEventListeners();
  }

  ensureAudioContext() {
    if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
  }

  addEventListeners() {
    this.recordBtn.addEventListener('click', () => this.startRecording());
    this.stopBtn.addEventListener('click', () => this.stopRecording());
    this.fileOpen.addEventListener('click', () => this.fileInput.click());
    this.fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
    this.playOriginal.addEventListener('click', () => this.playBuffer(this.originalBuffer));
    this.playReversed.addEventListener('click', () => this.playBuffer(this.reversedBuffer));
    this.downloadBtn.addEventListener('click', () => this.downloadReversed());
  }

  async startRecording() {
    this.ensureAudioContext();
    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      this.mediaRecorder = new MediaRecorder(stream);
      this.recordedChunks = [];
      this.mediaRecorder.ondataavailable = (e) => { if(e.data.size>0) this.recordedChunks.push(e.data) };
      this.mediaRecorder.onstop = async () => {
        const blob = new Blob(this.recordedChunks,{type:'audio/webm'});
        await this.loadArrayBuffer(await blob.arrayBuffer());
        stream.getTracks().forEach(t => t.stop());
      };
      this.mediaRecorder.start();
      this.recordBtn.textContent = 'Rec...';
      this.recordBtn.classList.add('recording');
      this.stopBtn.disabled = false;
    } catch(e) {
      alert('Microphone access denied.');
    }
  }

  stopRecording() {
    this.ensureAudioContext();
    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') this.mediaRecorder.stop();
    this.recordBtn.textContent = 'Rec';
    this.recordBtn.classList.remove('recording');
    this.stopBtn.disabled = true;
  }

  async handleFile(file) {
    if (!file) return;
    this.ensureAudioContext();
    const arrayBuffer = await file.arrayBuffer();
    await this.loadArrayBuffer(arrayBuffer, file.name);
  }

  async loadArrayBuffer(arrayBuffer, filename='Recording') {
    this.ensureAudioContext();
    this.originalBuffer = await this.audioCtx.decodeAudioData(arrayBuffer.slice(0));
    this.reversedBuffer = this.makeReversedBuffer(this.originalBuffer);
    this.meta.textContent = `${filename} — ${Math.round(this.originalBuffer.duration*10)/10}s`;
    this.playOriginal.disabled = false;
    this.playReversed.disabled = false;
    this.downloadBtn.disabled = false;
    this.drawWaveform(this.originalBuffer);
  }

  makeReversedBuffer(buffer) {
    const out = this.audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
    for (let ch=0; ch<buffer.numberOfChannels; ch++) {
      const inp = buffer.getChannelData(ch);
      const outd = out.getChannelData(ch);
      for (let i=0;i<buffer.length;i++) outd[i] = inp[buffer.length-1-i];
    }
    return out;
  }

  stopSources() {
    [this.originalSource,this.reversedSource].forEach(src => { try{ src?.stop() }catch(e){} });
    this.originalSource = this.reversedSource = null;
  }

  playBuffer(buffer) {
    if (!buffer) return;
    this.ensureAudioContext();
    this.stopSources();
    const source = this.audioCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(this.gainNode);
    source.start();
    if (buffer === this.originalBuffer) this.originalSource = source;
    else this.reversedSource = source;
  }

  drawWaveform(buffer) {
    const w = this.canvas.width;
    const h = this.canvas.height;
    this.ctx.clearRect(0,0,w,h);
    this.ctx.fillStyle = '#fff';
    this.ctx.fillRect(0,0,w,h);
    const data = buffer.getChannelData(0);
    const step = Math.max(1, Math.floor(data.length / w));
    this.ctx.strokeStyle = '#007aff';
    this.ctx.beginPath();
    for (let i=0;i<w;i++){
      const start = i*step;
      let min=1,max=-1;
      for (let j=0;j<step;j++){
        const v = data[start+j]; if(v<min) min=v; if(v>max) max=v;
      }
      const y1 = (1+min)*(h/2);
      const y2 = (1+max)*(h/2);
      this.ctx.moveTo(i,y1);
      this.ctx.lineTo(i,y2);
    }
    this.ctx.stroke();
  }

  bufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const bitsPerSample = 16;
    const blockAlign = numChannels * bitsPerSample / 8;
    const dataLen = buffer.length * blockAlign;
    const buf = new ArrayBuffer(44 + dataLen);
    const view = new DataView(buf);
    let pos=0;
    function writeString(s){ for(let i=0;i<s.length;i++) view.setUint8(pos++, s.charCodeAt(i)) }
    function write16(d){ view.setUint16(pos,d,true); pos+=2 }
    function write32(d){ view.setUint32(pos,d,true); pos+=4 }
    writeString('RIFF'); write32(36+dataLen); writeString('WAVE'); writeString('fmt ');
    write32(16); write16(1); write16(numChannels); write32(sampleRate);
    write32(sampleRate*blockAlign); write16(blockAlign); write16(bitsPerSample);
    writeString('data'); write32(dataLen);
    const channels = []; for(let c=0;c<numChannels;c++) channels.push(buffer.getChannelData(c));
    for(let i=0;i<buffer.length;i++) for(let c=0;c<numChannels;c++){
      let s = Math.max(-1,Math.min(1,channels[c][i]));
      s = s<0?s*0x8000:s*0x7FFF;
      view.setInt16(pos,s,true); pos+=2;
    }
    return new Blob([buf],{type:'audio/wav'});
  }

  downloadReversed() {
    if (!this.reversedBuffer) return;
    const wav = this.bufferToWav(this.reversedBuffer);
    const url = URL.createObjectURL(wav);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'reversed.wav';
    a.click();
    URL.revokeObjectURL(url);
  }
}

window.app = new ReverseAudioApp();
</script>
</body>
</html>
